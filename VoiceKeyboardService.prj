<?xml version="1.0" encoding="Shift_JIS" ?>
<!-- なんちゃってXML version 0.1( ObjectEditor専用 ) -->
<xobject>
<ID>project</ID>
<x0>0</x0>
<y0>0</y0>
<width>200</width>
<height>100</height>
<ID_maker>53</ID_maker>
<objectname>VoiceKeyboardService</objectname>
<description>新規のアプリケーション</description>
<プロパティ>
<ID>properties</ID>
<LookandFeel>javax.swing.plaf.metal.MetalLookAndFeel</LookandFeel>
<MainWinx0>0</MainWinx0>
<MainWiny0>0</MainWiny0>
<MainWinWidth>1024</MainWinWidth>
<MainWinHeight>745</MainWinHeight>
<MesgWinx0>0</MesgWinx0>
<MesgWiny0>0</MesgWiny0>
<MesgWinWidth>1024</MesgWinWidth>
<MesgWinHeight>741</MesgWinHeight>
<FileWinx0>412</FileWinx0>
<FileWiny0>163</FileWiny0>
<FileWinWidth>578</FileWinWidth>
<FileWinHeight>262</FileWinHeight>
<EditWinx0>347</EditWinx0>
<EditWiny0>0</EditWiny0>
<EditWinWidth>676</EditWinWidth>
<EditWinHeight>541</EditWinHeight>
<PropWinx0>228</PropWinx0>
<PropWiny0>15</PropWiny0>
<PropWinWidth>615</PropWinWidth>
<PropWinHeight>448</PropWinHeight>
<DividerLocation1>2</DividerLocation1>
<DividerLocation2>2</DividerLocation2>
<ToolBarVisible>1</ToolBarVisible>
<ViewSourceAtCompile>0</ViewSourceAtCompile>
<NoSourceCreate>0</NoSourceCreate>
<JavaEditCommand>geany</JavaEditCommand>
<JavaViewCommand></JavaViewCommand>
<HelpCommand></HelpCommand>
<ApplicationType>4</ApplicationType>
<CompileCommand0>./compile_java</CompileCommand0>
<RunCommand0>./run_java</RunCommand0>
<GUIDesignerCommand0>java -jar guidsin.jar -java</GUIDesignerCommand0>
<ImportFiles0> import java.awt.*;
 import java.awt.event.*;
 import javax.swing.*;
 import javax.swing.event.*;
 import javax.swing.tree.*;
 import java.io.*;
 import java.net.*;
 import java.util.*;
import java.awt.geom.*;
import java.awt.print.*;
import javax.swing.border.*;
import javax.swing.filechooser.*;
 import javax.swing.*;
 import javax.swing.event.*;
 import javax.swing.tree.*;
 import java.io.*;
 import java.net.*;
 import java.util.*;
import java.awt.image.BufferedImage;
import javax.sound.sampled.*;

class Starter{
  public static void main( String args[] ){
    %AppName% ap = new %AppName%();
    ap.ARGS = args;
    ap.Start();
  }
}
</ImportFiles0>
<ProgramStartupCode0> String[] ARGS;
</ProgramStartupCode0>
<NativeHelpCommand0></NativeHelpCommand0>
<CompileCommand1></CompileCommand1>
<RunCommand1></RunCommand1>
<GUIDesignerCommand1>java -jar guidsin.jar -applet</GUIDesignerCommand1>
<ImportFiles1> import java.awt.*;
 import java.awt.event.*;
 import java.applet.*;
 import javax.swing.*;
 import javax.swing.event.*;
 import javax.swing.tree.*;
 import java.io.*;
 import java.net.*;
 import java.util.*;
 public class javatext extends Applet {
   %AppName% ap;
   public void init() {
     ap = new %AppName%();
     ap.APPLET = this;
     ap.Start();
   }
 }
</ImportFiles1>
<ProgramStartupCode1> Applet APPLET;
</ProgramStartupCode1>
<NativeHelpCommand1></NativeHelpCommand1>
<CompileCommand2></CompileCommand2>
<RunCommand2></RunCommand2>
<GUIDesignerCommand2></GUIDesignerCommand2>
<ImportFiles2>#include &lt;stdio.h&gt;

void Startup();
</ImportFiles2>
<ProgramStartupCode2>int main(){
 Startup();
 %AppName%::Start();
 }
</ProgramStartupCode2>
<NativeHelpCommand2></NativeHelpCommand2>
<CompileCommand3></CompileCommand3>
<RunCommand3></RunCommand3>
<GUIDesignerCommand3>java -jar guidsin.jar -cpp</GUIDesignerCommand3>
<ImportFiles3>#include &lt;stdio.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;math.h&gt;
#include &quot;Ekagen.h&quot;
void Startup();
</ImportFiles3>
<ProgramStartupCode3>void Emain(){
Startup();
%AppName%::Start();
}
</ProgramStartupCode3>
<NativeHelpCommand3></NativeHelpCommand3>
<MoveStep>8</MoveStep>
<ImageEditCommand>mtpaint</ImageEditCommand>
<CompilerFileName>javac.exe</CompilerFileName>
<CompileCommand4>./compile_vkeyboard_service VKeyboardService com example vkeyboard_service</CompileCommand4>
<RunCommand4>echo no action</RunCommand4>
<GUIDesignerCommand4>java -jar guidsin.jar -android</GUIDesignerCommand4>
<ImportFiles4>package com.example.test;

import android.os.Bundle;
import android.graphics.Matrix;
import android.graphics.Typeface;
import android.graphics.RectF;
import android.graphics.BitmapFactory;
import java.io.*;
import java.net.*;
import java.util.*;
import java.text.SimpleDateFormat;
import android.media.MediaPlayer;
import android.os.Handler;
import android.content.res.Configuration;
import android.graphics.Color;
import android.hardware.Camera;
import android.app.Notification;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.media.MediaPlayer;
import android.os.IBinder;
import android.util.Log;
import android.widget.Toast;

import android.media.AudioFormat;
import android.media.AudioRecord;
import android.media.MediaRecorder;
import java.security.*;
import java.util.Base64;
import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.util.Base64;
import java.nio.charset.StandardCharsets;
import java.security.interfaces.RSAPrivateKey;
import java.math.BigInteger;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.security.KeyFactory;
import java.security.spec.PKCS8EncodedKeySpec;
import android.os.Environment;
import android.media.MediaPlayer;
import android.app.Notification;
import android.app.NotificationManager;

public class HelloWorld extends Service {
  %AppName% ap;
 
    @Override
    public void onCreate() {
      super.onCreate();
      ap = new %AppName%();
      ap.SERVICE = this;
    }
 
    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        ap.Start();
        return START_STICKY;
    }
 
    @Override
    public void onDestroy() {
    }

    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }

}
</ImportFiles4>
<ProgramStartupCode4>IntentService SERVICE;
</ProgramStartupCode4>
<NativeHelpCommand4>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    package=&quot;com.example.test&quot;
    android:versionCode=&quot;1&quot;
    android:versionName=&quot;1.0&quot; &gt;
   
  &lt;uses-sdk android:minSdkVersion=&quot;3&quot; android:targetSdkVersion=&quot;21&quot;/&gt;
  &lt;uses-feature android:name=&quot;android.hardware.camera&quot; /&gt; 
  &lt;uses-feature android:name=&quot;android.hardware.usb.host&quot; /&gt; 
  &lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt;
  &lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt; 
  &lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot;/&gt;
  &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt; 
  &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;
  &lt;application android:label=&quot;@string/app_name&quot; &gt;
        &lt;activity
            android:name=&quot;ServiceStartActivity&quot;
            android:label=&quot;@string/app_name&quot; &gt;
            &lt;intent-filter&gt;
                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
            &lt;/intent-filter&gt;
        &lt;/activity&gt;
        &lt;service android:name=&quot;HelloWorld&quot;
                 android:exported=&quot;true&quot;
        &gt;
        &lt;/service&gt;
  &lt;/application&gt;
&lt;/manifest&gt;
</NativeHelpCommand4>
<HtmlEditCommand></HtmlEditCommand>
<CompileCommand5></CompileCommand5>
<RunCommand5></RunCommand5>
<GUIDesignerCommand5></GUIDesignerCommand5>
<ImportFiles5></ImportFiles5>
<ProgramStartupCode5>gosub @_PSTART
end
</ProgramStartupCode5>
<NativeHelpCommand5></NativeHelpCommand5>
<NoOptimizePin>0</NoOptimizePin>
<CompileCommand6>./compile_c</CompileCommand6>
<RunCommand6>./run_c</RunCommand6>
<GUIDesignerCommand6></GUIDesignerCommand6>
<ImportFiles6>#include &lt;setjmp.h&gt;
#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;math.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netdb.h&gt;

#include &lt;X11/Xlib.h&gt;
#include &lt;X11/Xutil.h&gt;
#include &lt;X11/Xlocale.h&gt; /* ロケール用ヘッダーファイル */
#include &lt;X11/xpm.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;signal.h&gt;
#include &lt;unistd.h&gt;
#include &lt;termios.h&gt;
#include &lt;errno.h&gt;
</ImportFiles6>
<ProgramStartupCode6>int ARGC; char** ARGV;
int main( int argc, char** argv ){
  ARGC=argc;
  ARGV=argv;
  _PSTART();
}
</ProgramStartupCode6>
<NativeHelpCommand6></NativeHelpCommand6>
<CompileCommand7></CompileCommand7>
<RunCommand7>./run_startx</RunCommand7>
<GUIDesignerCommand7>java -jar guidsin.jar -ore</GUIDesignerCommand7>
<ImportFiles7></ImportFiles7>
<ProgramStartupCode7>main:
  _INIT_STATES
  goto _PSTART
</ProgramStartupCode7>
<NativeHelpCommand7></NativeHelpCommand7>
<IDF_LocalVariable5>%</IDF_LocalVariable5>
<IDF_LocalVariable7>\</IDF_LocalVariable7>
</プロパティ>
<codeclip>
<ID>_CSTART</ID>
<x0>324</x0>
<y0>393</y0>
<width>170</width>
<height>34</height>
<codetext>Service SERVICE;
int SERICE_ID=655;
</codetext>
</codeclip>
<pin>
<ID>_PSTART</ID>
<x0>98</x0>
<y0>431</y0>
<width>55</width>
<height>24</height>
<text>Start()</text>
<px>50</px>
<py>50</py>
</pin>
<codeclip>
<ID>_C17</ID>
<x0>323</x0>
<y0>128</y0>
<width>288</width>
<height>161</height>
<codetext>// 変数
Handler handler = new Handler();
NotificationManager notifManager;
Notification notif;
double[] voice;      // 録音した音声
double[] hosei;      // 聴覚感度補正係数
int voice_no = 0;  // 音声番号
int tsize = 0;       // テンプレートのサイズ
boolean is_running = false; // 実行中フラグ
boolean is_active=false;  // キーボード有効
</codetext>
</codeclip>
<codeclip>
<ID>_C18</ID>
<x0>324</x0>
<y0>292</y0>
<width>286</width>
<height>99</height>
<codetext>// 定数
static final int SAMPLING_RATE = 16000;
static final int HEARING_WIDTH = 40;
static final int HEARING_HEIGHT = 128;
static final int SOUND_DFT_SIZE = 256;
static final int TRIGGER_MARGIN = 2;
</codetext>
</codeclip>
<codeclip>
<ID>_C28</ID>
<x0>614</x0>
<y0>380</y0>
<width>236</width>
<height>170</height>
<codetext>// デバッグオブジェクト
String DEBUG_FILE = &quot;debug.txt&quot;;
FileWriter dbg;
boolean debug_mode = false;
public void dprint(String s){
  if(debug_mode){
    try{
      dbg.write(s);
      dbg.flush();
    } catch(Exception e){}
  }
}
</codetext>
</codeclip>
<codeclip>
<ID>_C30</ID>
<x0>8</x0>
<y0>127</y0>
<width>315</width>
<height>266</height>
<codetext>// 各種パラメータ
int bright = 0;  // 声紋表示の輝度調節
int startup_time = 400;
boolean flog_scale = false;//周波数対数スケール
boolean alog_scale = false;//振幅対数スケール
boolean auto_learn = false; // 自動学習有効
double sound_filter = 200;
double thresh_trigger_on = 3;
double thresh_trigger_off = 3;
int thresh_count_on = 4;
int thresh_count_off = 10;
double thresh_recognize = 0.1;
double bias = 3; // ノイズ抑制用バイアス
double acompress = 0.3;  // 振幅圧縮係数
double learn_param_o = 8;   // 学習パラメータ
double learn_param_x =128; // 学習パラメータ
double limit_length = 1.2; // 音声の長さ比較用

</codetext>
</codeclip>
<xobject>
<ID>_X34</ID>
<x0>180</x0>
<y0>517</y0>
<width>175</width>
<height>61</height>
<objectname>Control</objectname>
<description></description>
<ID_maker>142</ID_maker>
<pin>
<ID>_P88</ID>
<x0>62</x0>
<y0>258</y0>
<width>60</width>
<height>30</height>
<text>start()</text>
<px>118</px>
<py>11</py>
</pin>
<operation>
<ID>_O89</ID>
<state1>_SINIT</state1>
<state2>_SINIT</state2>
<x0>176</x0>
<y0>260</y0>
<width>103</width>
<height>46</height>
<inconnectx0>0</inconnectx0>
<inconnecty0>40</inconnecty0>
<outconnectx0>0</outconnectx0>
<outconnecty0>40</outconnecty0>
<inpintext>in()</inpintext>
<inpinx0>0</inpinx0>
<inpiny0>28</inpiny0>
<inpinwidth>40</inpinwidth>
<inpinheight>20</inpinheight>
<outpintext>out()</outpintext>
<outpinx0>90</outpinx0>
<outpiny0>40</outpiny0>
<outpinwidth>40</outpinwidth>
<outpinheight>20</outpinheight>
<inpinlinkcount>1</inpinlinkcount>
<description></description>
<codetext>// 初期設定


// 通知用変数を取得
Intent intent = new Intent(android.content.Intent.ACTION_VIEW);
//intent.setData(Uri.parse(&quot;http://www.google.com/&quot;));

PendingIntent pendingIntent
	= PendingIntent.getActivity(
		SERVICE,
		0,
		intent,
		0);

notifManager = (NotificationManager)SERVICE.getSystemService(Context.NOTIFICATION_SERVICE);
notif = new Notification(R.drawable.ic_launcher, &quot;音声キーボードが有効です&quot;, System.currentTimeMillis());

// 通知を選択した時に自動的に通知が消えるための設定
notif.flags = Notification.FLAG_AUTO_CANCEL;

// &quot;Latest Event&quot; レイアウトの設定
notif.setLatestEventInfo(
		SERVICE,
		&quot;音声キーボード&quot;,
		&quot;有効&quot;,
		pendingIntent);


// 音声認識用三角関数テーブルを作成
  sin_table = new double[HEARING_HEIGHT][SOUND_DFT_SIZE];
  cos_table = new double[HEARING_HEIGHT][SOUND_DFT_SIZE];

// 対数スケールの場合
if(flog_scale){
  int[] dist  = new int[HEARING_HEIGHT+1]; // 周波数分布テーブル
  double p = Math.pow( HEARING_HEIGHT-1.0, 1.0 / HEARING_HEIGHT );
  for( int i = 0; i &lt;= HEARING_HEIGHT; i++ ){
    int d = (int)(Math.pow( p, (double)i ));
    dist[i] = i+1 &gt;= d? i+1 : d;
  }
  for(int i = 0; i &lt; HEARING_HEIGHT; i++){
    for(int j = 0; j &lt; SOUND_DFT_SIZE; j++){
      sin_table[i][j] = 0;
      cos_table[i][j] = 0;
      double r = 1 / Math.sqrt(dist[i+1] - dist[i]);
      for(int k = dist[i]; k &lt; dist[i+1]; k++){
        sin_table[i][j] += r * Math.sin(k * j * 6.2832 / SOUND_DFT_SIZE);
        cos_table[i][j] += r * Math.cos(k * j * 6.2832 / SOUND_DFT_SIZE);
      }
    }
  }
}

// リニアスケールの場合
else{
  for(int i = 0; i &lt; HEARING_HEIGHT; i++){
    for(int j = 0; j &lt; SOUND_DFT_SIZE; j++){
      sin_table[i][j] = Math.sin(i * j * 6.2832 / SOUND_DFT_SIZE);
      cos_table[i][j] = Math.cos(i * j * 6.2832 / SOUND_DFT_SIZE);
    }
  }
}


// 録音スレッドを開始
is_running = true;
record_thread = new RecordThread();
record_thread.start();

</codetext>
</operation>
<relation>
<ID>_R90</ID>
<pin1name>_P88</pin1name>
<pin2name>_O89</pin2name>
</relation>
<pin>
<ID>_P102</ID>
<x0>313</x0>
<y0>123</y0>
<width>146</width>
<height>28</height>
<text>result(int i, double[] v)</text>
<px>177</px>
<py>78</py>
</pin>
<codeclip>
<ID>_C105</ID>
<x0>27</x0>
<y0>11</y0>
<width>224</width>
<height>36</height>
<codetext>// 三角関数テーブル
double[][] sin_table, cos_table;
</codetext>
</codeclip>
<operation>
<ID>_O112</ID>
<state1>_SINIT</state1>
<state2>_SINIT</state2>
<x0>414</x0>
<y0>24</y0>
<width>210</width>
<height>80</height>
<inconnectx0>0</inconnectx0>
<inconnecty0>40</inconnecty0>
<outconnectx0>0</outconnectx0>
<outconnecty0>40</outconnecty0>
<inpintext>in(int i, double[] v)</inpintext>
<inpinx0>0</inpinx0>
<inpiny0>58</inpiny0>
<inpinwidth>120</inpinwidth>
<inpinheight>22</inpinheight>
<outpintext>out(int key)</outpintext>
<outpinx0>122</outpinx0>
<outpiny0>59</outpiny0>
<outpinwidth>80</outpinwidth>
<outpinheight>22</outpinheight>
<inpinlinkcount>1</inpinlinkcount>
<description></description>
<codetext>// 音声キーボードが有効なら
// 通知してタイプする
// 自動学習が有効なら学習する



// 認識に失敗したときは学習データを破棄して終了
if(v == null){
  learn_voice_no = -1;
  learn_voice = null;
  return;
}


// 認識に成功したとき
else{
  VoiceTemplate vt = (VoiceTemplate)(voice_template.get(i));

  // 認識結果が&quot;モード切替&quot;のとき
  if(vt.text.equals(&quot;モード切替&quot;)){

    // 音声キーボードの有効/無効の切り替え
    is_active = !is_active;

    // 有効になったら通知ON
    if(is_active){
      notifManager.notify(R.string.app_name, notif);
    }

    // 無効になったら通知OFFしてデータを保存する
    else{
      notifManager.cancel(R.string.app_name);
      save();
    }
    
    // 学習データを破棄して終了
    learn_voice_no = -1;
    learn_voice = null;
    return;
  }

  // 音声認識が有効でない場合
  if(!is_active){

    // 学習データを破棄して終了
    learn_voice_no = -1;
    learn_voice = null;
    return;
  }

  // 音声認識が有効な場合
  else{

    // 自動学習が有効な場合
    if(auto_learn){
  
      // 認識結果が&quot;違う&quot;ときはペナルティ付きの学習をして学習データを破棄する
      if(vt.text.equals(&quot;違う&quot;)){
        if(learn_voice_no &gt;= 0 &amp;&amp; learn_voice != null){
          double[] w =((VoiceTemplate)(voice_template.get(learn_voice_no))).voice;
          for(int j = 0; j &lt; w.length; j++){
            double d = 0;
            if(j &lt; learn_voice.length) d = learn_voice[j];
            w[j] = ((learn_param_x - 1.0) * w[j] - d) / learn_param_x;
          }
        }
        learn_voice_no = -1;
        learn_voice = null;
      }

      // そうでない場合は報酬付きの学習をして次回の学習のためのデータを用意する
      else{
        if(learn_voice_no &gt;= 0 &amp;&amp; learn_voice != null){
          double[] w =((VoiceTemplate)(voice_template.get(learn_voice_no))).voice;
          for(int j = 0; j &lt; w.length; j++){
            double d = 0;
            if(j &lt; learn_voice.length) d = learn_voice[j];
            w[j] = ((learn_param_o - 1.0) * w[j] + d) / learn_param_o;
          }
        }
        learn_voice_no = i;
        learn_voice = new double[v.length];
        for(int j = 0; j &lt; v.length;j++){
          learn_voice[j] = v[j];
        }
      }
    }

    // タイプするキーコードをセットする
    key = vt.code;
  }
}

</codetext>
</operation>
<relation>
<ID>_R113</ID>
<pin1name>_P102</pin1name>
<pin2name>_O112</pin2name>
</relation>
<pin>
<ID>_P114</ID>
<x0>595</x0>
<y0>123</y0>
<width>86</width>
<height>28</height>
<text>type(int key)</text>
<px>80</px>
<py>39</py>
</pin>
<relation>
<ID>_R115</ID>
<pin1name>_O112</pin1name>
<pin2name>_P114</pin2name>
</relation>
<codeclip>
<ID>_C120</ID>
<x0>27</x0>
<y0>53</y0>
<width>262</width>
<height>54</height>
<codetext>// 録音スレッド
RecordThread record_thread = null;
class RecordThread extends Thread {

  int state;
  static final int NEUTRAL = 0;
  static final int OFF = 1;
  static final int SENS_ON = 2;
  static final int ON = 3;
  static final int SENS_OFF = 4;
  int HEARING_BUFFER_SIZE = 65536;

  public void run() {
    int i, j, k, len, width, height, state, offset, count;
    int start_point, end_point;
    double   a, u, v, x, y, trigger, pow;

dprint(&quot;start rec thread\n&quot;);

    // 音声データのバッファサイズ (byte)を設定
    int audio_buffer_size = android.media.AudioRecord.getMinBufferSize(
                     SAMPLING_RATE,
                     AudioFormat.CHANNEL_IN_MONO,
                     AudioFormat.ENCODING_PCM_16BIT
    );

    // AudioRecordの作成
     AudioRecord audioRec = new AudioRecord(
                     MediaRecorder.AudioSource.MIC,
                     SAMPLING_RATE,
                     AudioFormat.CHANNEL_IN_MONO,
                     AudioFormat.ENCODING_PCM_16BIT,
                     audio_buffer_size
     );
    audioRec.startRecording();	// 録音開始
    state = NEUTRAL;
    offset = 0;
    count = 0;
    start_point = end_point = 0;
    short[]  sound_buffer   = new short[SOUND_DFT_SIZE];
    double[] sound_av       = new double[HEARING_HEIGHT];
    double[] hearing_buffer = new double[HEARING_BUFFER_SIZE];

    while(is_running){       

      // 録音データを読み込む(SOUND_DFT_SIZEは配列要素の数)
      audioRec.read(sound_buffer, 0, SOUND_DFT_SIZE);

      // 取り込んだ聴覚データをDFTして開けておいたところにセットする
      // 振幅が対数スケールの場合
      if(alog_scale){
        trigger = 0.0;
        for( i = 0; i &lt; HEARING_HEIGHT; i++ ){
          for( x = y = 0.0, j = 0; j &lt; SOUND_DFT_SIZE; j++ ){
            a = (double)sound_buffer[j];
            x += a * cos_table[i][j];
            y += a * sin_table[i][j];
          }
          pow = Math.log((x * x + y * y) + bias);       // 微小なノイズを抑制するためバイアスをかける
          hearing_buffer[i + offset] = pow * hosei[i];  // 必要ならば人間の聴覚に合わせて補正をかける
          sound_av[i] = ((sound_filter - 1.0) * sound_av[i] + pow) / sound_filter;
          pow /= sound_av[i];
          if(pow &gt; trigger) trigger = pow;
        }
      }

      // 振幅がリニアスケールの場合
      else{
        trigger = 0.0;
        for( i = 0; i &lt; HEARING_HEIGHT; i++ ){
          for( x = y = 0.0, j = 0; j &lt; SOUND_DFT_SIZE; j++ ){
            a = (double)sound_buffer[j];
            x += a * cos_table[i][j];
            y += a * sin_table[i][j];
          }
          pow = Math.pow( (x * x + y * y), acompress );
          hearing_buffer[i + offset] = pow * hosei[i];  // 必要ならば人間の聴覚に合わせて補正をかける
          sound_av[i] = ((sound_filter - 1.0) * sound_av[i] + pow) / sound_filter;
          pow /= sound_av[i];
          if(pow &gt; trigger) trigger = pow;
        }
      }
      
      // 状態ごとの動作を以下に記述
      switch(state){
          
      // NEWTRAL状態：起動してしばらくは各フィルタ変数が安定するのを待つ
      case NEUTRAL:
        if(count &gt; startup_time){
           state = OFF;
        }
        break;

      // OFF状態
      case OFF:
        if(trigger &gt; thresh_trigger_on){
          state = SENS_ON;
          start_point = offset - TRIGGER_MARGIN*HEARING_HEIGHT;  // スレッショルドを越える直前をサンプリング開始位置とする
          if(start_point &lt; 0) start_point += HEARING_BUFFER_SIZE;
          count = 0;
        }
        break;

      // OFFからONに遷移する状態
      case SENS_ON:
        if(trigger &lt; thresh_trigger_off)  state = OFF;
        else{
          if(count &gt; thresh_count_on) state = ON;
        }
        break;

      // ON状態
      case ON:
        if(trigger &lt; thresh_trigger_off){
          state = SENS_OFF;
          end_point = offset + TRIGGER_MARGIN*HEARING_HEIGHT; // スレッショルドを下回った所をサンプリング終了位置とする
          if(end_point &gt;= HEARING_BUFFER_SIZE) end_point -= HEARING_BUFFER_SIZE;
          count = 0;
        }
        break;

      // ONからOFFに遷移する状態
      case SENS_OFF:
        if(trigger &gt; thresh_trigger_on)  state = ON;
        else{
          if(count &gt; thresh_count_off){

            // サンプリング範囲内のデータを音声データ配列voiceに転送する
            len = end_point - start_point;
            if(len &lt; 0) len += HEARING_BUFFER_SIZE;
            voice = new double[len];
            for(i = start_point, j = 0; j &lt; len; i++, j++){
              if(i &gt;= HEARING_BUFFER_SIZE) i -= HEARING_BUFFER_SIZE;
              voice[j] = hearing_buffer[i];
            }
            state = OFF;

            // 認識処理開始
            new Thread(new Runnable() {
	          @Override
	          public void run() {
                recognize(voice);
	          }
	        }).start();

          }
        }
        break;

      }

      offset += HEARING_HEIGHT;
      if( offset &gt;= HEARING_BUFFER_SIZE ) offset = 0;
      count++;
    }
    audioRec.stop();	// 録音終了
    audioRec.release();

  }//run()

}//RecordThread
</codetext>
</codeclip>
<codeclip>
<ID>_C119</ID>
<x0>27</x0>
<y0>155</y0>
<width>465</width>
<height>36</height>
<codetext>// 2つの音声を比較して相関値を返す(offsetはずらす位置)
public double compare_voice( double[] ref, double[] voice, int offset ){

  int x, y, width, height;
  double a = 0.0, nn = 0.0, ar = 0.0, av = 0.0, pr = 0.0, pv = 0.0;

  if( voice == null || ref == null ) return 0.0;
  if( voice.length &lt;= 0 || ref.length &lt;=0 ) return 0.0;
    
  // 右側にずらす場合
  if( offset &gt;=1 ){
    if( voice.length &lt;= offset * HEARING_HEIGHT ) return 0.0;
    
    // ずらす voice-&gt;xvoice
    double[] xvoice = new double[voice.length - offset * HEARING_HEIGHT];
    for( int i = 0; i &lt; xvoice.length; i++ ) xvoice[i] = voice[i + offset * HEARING_HEIGHT];

    width = ref.length / HEARING_HEIGHT;
    if( ( x= xvoice.length / HEARING_HEIGHT ) &lt; width ) width = x;
    height  = HEARING_HEIGHT;
    nn = (double)( width * height );

    // ref[]の平均値を求める
    ar = 0.0;
    for( x = 0; x &lt; width; x++ ){
      for( y = 0; y &lt; height; y++ ){
        ar += ref[ HEARING_HEIGHT * x + y ];
      }
    }
    ar /= nn; 

    // xvoice[]の平均値を求める
    av = 0.0;
    for( x = 0; x &lt; width; x++ ){
      for( y = 0; y &lt; height; y++ ){
        av += xvoice[ HEARING_HEIGHT * x + y ];
      }
    }
    av /= nn; 

    // ref[]のパワーを求める
     pr = 0.0;
    for( x = 0; x &lt; width; x++ ){
      for( y = 0; y &lt; height; y++ ){
        a = ref[ HEARING_HEIGHT * x + y ] - ar;
        pr += a * a;
      }
    }
    if( pr == 0.0 ) return 0.0;

    // xvoice[]のパワーを求める
    pv = 0.0;
    for( x = 0; x &lt; width; x++ ){
      for( y = 0; y &lt; height; y++ ){
        a = xvoice[ HEARING_HEIGHT * x + y ] - av;
        pv += a * a;
      }
    }
    if( pv == 0.0 ) return 0.0;

    // ref[]とxvoice[]の相関値を求める
    a = 0.0;
    for( x = 0; x &lt; width; x++ ){
      for( y = 0; y &lt; height; y++ ){
        a += ( ref[ HEARING_HEIGHT * x + y ] - ar ) * ( xvoice[ HEARING_HEIGHT * x + y ] - av ) ;
      }
    }
    return a / Math.sqrt( pv * pr );
  }


  // 左側にずらす場合
  else if( offset &lt;= -1 ){
    if( ref.length &lt;= -offset * HEARING_HEIGHT ) return 0.0;
    
    // ずらす ref-&gt;xref
    double[] xref = new double[ref.length + offset * HEARING_HEIGHT];
    for( int i = 0; i &lt; xref.length; i++ ) xref[i] = ref[i - offset * HEARING_HEIGHT];

    width  = xref.length / HEARING_HEIGHT;
    if( ( x= voice.length / HEARING_HEIGHT ) &lt; width ) width = x;
    height  = HEARING_HEIGHT;
    nn = (double)( width * height );

    // xref[]の平均値を求める
    ar = 0.0;
    for( x = 0; x &lt; width; x++ ){
      for( y = 0; y &lt; height; y++ ){
        ar += xref[ HEARING_HEIGHT * x + y ];
      }
    }
    ar /= nn; 

    // voice[]の平均値を求める
    av = 0.0;
    for( x = 0; x &lt; width; x++ ){
      for( y = 0; y &lt; height; y++ ){
        av += voice[ HEARING_HEIGHT * x + y ];
      }
    }
    av /= nn; 

    // xref[]のパワーを求める
    pr = 0.0;
    for( x = 0; x &lt; width; x++ ){
      for( y = 0; y &lt; height; y++ ){
        a = xref[ HEARING_HEIGHT * x + y ] - ar;
        pr += a * a;
      }
    }
    if( pr == 0.0 ) return 0.0;

    // voice[]のパワーを求める
    pv = 0.0;
    for( x = 0; x &lt; width; x++ ){
      for( y = 0; y &lt; height; y++ ){
        a = voice[ HEARING_HEIGHT * x + y ] - av;
        pv += a * a;
      }
    }
    if( pv == 0.0 ) return 0.0;

    // xref[]とvoice[]の相関値を求める
    a = 0.0;
    for( x = 0; x &lt; width; x++ ){
      for( y = 0; y &lt; height; y++ ){
        a += ( xref[ HEARING_HEIGHT * x + y ] - ar ) * ( voice[ HEARING_HEIGHT * x + y ] - av ) ;
      }
    }
    return a / Math.sqrt( pv * pr );
  }

  // ずらさない場合
  else{

    width  = ref.length / HEARING_HEIGHT;
    if( ( x= voice.length / HEARING_HEIGHT ) &lt; width ) width = x;
    height  = HEARING_HEIGHT;
    nn = (double)( width * height );

    // ref[]の平均値を求める
    ar = 0.0;
    for( x = 0; x &lt; width; x++ ){
      for( y = 0; y &lt; height; y++ ){
        ar += ref[ HEARING_HEIGHT * x + y ];
      }
    }
    ar /= nn; 

    // voice[]の平均値を求める
    av = 0.0;
    for( x = 0; x &lt; width; x++ ){
      for( y = 0; y &lt; height; y++ ){
        av += voice[ HEARING_HEIGHT * x + y ];
      }
    }
    av /= nn; 

    // ref[]のパワーを求める
    pr = 0.0;
    for( x = 0; x &lt; width; x++ ){
      for( y = 0; y &lt; height; y++ ){
        a = ref[ HEARING_HEIGHT * x + y ] - ar;
        pr += a * a;
      }
    }
    if( pr == 0.0 ) return 0.0;

    // voice[]のパワーを求める
    pv = 0.0;
    for( x = 0; x &lt; width; x++ ){
      for( y = 0; y &lt; height; y++ ){
        a = voice[ HEARING_HEIGHT * x + y ] - av;
        pv += a * a;
      }
    }
    if( pv == 0.0 ) return 0.0;

    // ref[]とvoice[]の相関値を求める
    a = 0.0;
    for( x = 0; x &lt; width; x++ ){
      for( y = 0; y &lt; height; y++ ){
        a += ( ref[ HEARING_HEIGHT * x + y ] - ar ) * ( voice[ HEARING_HEIGHT * x + y ] - av ) ;
      }
    }
    return a / Math.sqrt( pv * pr );
  }

}
</codetext>
</codeclip>
<codeclip>
<ID>_C118</ID>
<x0>27</x0>
<y0>115</y0>
<width>264</width>
<height>33</height>
<codetext>// 音声の認識
public void recognize( double[] voice) {
    
  int maxi = 0;
  double r = 0.0, max = 0.0;
  for( int i = 0; i &lt; voice_template.size(); i++ ){

    // テンプレートの音声
    double[] ref = ((VoiceTemplate)(voice_template.get(i))).voice;

    // 音声の長さを比べて範囲内なら比較する
    double p = (double)ref.length / voice.length;
    if(p &lt; limit_length &amp;&amp; 1/p &lt; limit_length){

      // 重み(大きいほど優先順位が高くなる)
      double w = ((VoiceTemplate)(voice_template.get(i))).weight;

      // テンプレートと録音した音声の相関値を計算する(トリガタイミングの誤差を考慮して少しずつずらして比較して一番大きいのをとる)
      r = compare_voice( ref, voice, -2 ) * w;
      if(r &gt; max){ max = r; maxi = i; }

      r = compare_voice( ref, voice, -1 ) * w;
      if(r &gt; max){ max = r; maxi = i; }

      r = compare_voice( ref, voice, 0  ) * w;
      if(r &gt; max){ max = r; maxi = i; }

      r = compare_voice( ref, voice, 1  ) * w; 
      if(r &gt; max){ max = r; maxi = i; }

      r = compare_voice( ref, voice, 2  ) * w;
      if(r &gt; max){ max = r; maxi = i; }

    }
  }
      
  // 認識が成功したとき
  if( max &gt; thresh_recognize ){
    result(maxi, voice);
  }
  
  // 認識が失敗したとき
  else{
    result(-1, null);  
  }
}
</codetext>
</codeclip>
<codeclip>
<ID>_C141</ID>
<x0>26</x0>
<y0>198</y0>
<width>202</width>
<height>48</height>
<codetext>// 学習用の音声
int learn_voice_no = -1;
double[] learn_voice = null;
</codetext>
</codeclip>
</xobject>
<codeclip>
<ID>_C37</ID>
<x0>616</x0>
<y0>126</y0>
<width>359</width>
<height>216</height>
<codetext>// 音声テンプレート
Vector voice_template;
class VoiceTemplate{
  String text;    // 表示テキスト
  double weight; // 重み係数(音声認識の優先度)
  int code;        // キーコード
  double[] voice; // 音声データ
  VoiceTemplate( String t, double w, int c, double[] v ){
    text = t;
    weight = w;
    code = c;
    voice = v;  
  }
}

</codetext>
</codeclip>
<codeclip>
<ID>_C40</ID>
<x0>615</x0>
<y0>346</y0>
<width>242</width>
<height>32</height>
<codetext>// 音声テンプレートファイル
File voice_data_file = new File( Environment.getExternalStorageDirectory(),&quot;VoiceData.txt&quot; );
</codetext>
</codeclip>
<codeclip>
<ID>_C41</ID>
<x0>224</x0>
<y0>18</y0>
<width>441</width>
<height>96</height>
<codetext>// 音声キーボードサービスプログラム for android  ver 0.2.3
// 変更点：
// 学習アルゴリズムを改良
// 自動学習機能を追加
// 音声認識アルゴリズムを改良
// ADB接続でキー入力コマンドを実行するのでroot権限が必要でなくなった
</codetext>
</codeclip>
<xobject>
<ID>_X42</ID>
<x0>380</x0>
<y0>497</y0>
<width>138</width>
<height>80</height>
<objectname>ADB_keyboad</objectname>
<description></description>
<codeclip>
<ID>_C41</ID>
<x0>167</x0>
<y0>60</y0>
<width>212</width>
<height>19</height>
<codetext>byte recv[] = new byte[256];</codetext>
</codeclip>
<codeclip>
<ID>_C40</ID>
<x0>168</x0>
<y0>148</y0>
<width>159</width>
<height>18</height>
<codetext>byte close[] ={
(byte)0x43 ,(byte)0x4c ,(byte)0x53 ,(byte)0x45,
(byte)0x23 ,(byte)0x0e ,(byte)0x00 ,(byte)0x00,
(byte)0xaa ,(byte)0x00 ,(byte)0x00 ,(byte)0x00,
(byte)0x00 ,(byte)0x00 ,(byte)0x00 ,(byte)0x00,
(byte)0x00 ,(byte)0x00 ,(byte)0x00 ,(byte)0x00,
(byte)0xbc ,(byte)0xb3 ,(byte)0xac ,(byte)0xba
};
</codetext>
</codeclip>
<codeclip>
<ID>_C39</ID>
<x0>166</x0>
<y0>124</y0>
<width>141</width>
<height>18</height>
<codetext>byte open[] = {
(byte)0x4f ,(byte)0x50 ,(byte)0x45 ,(byte)0x4e,
(byte)0x0b ,(byte)0x00 ,(byte)0x00 ,(byte)0x00,
(byte)0x00 ,(byte)0x00 ,(byte)0x00 ,(byte)0x00,
(byte)0x18 ,(byte)0x00 ,(byte)0x00 ,(byte)0x00,
(byte)0x98 ,(byte)0x08 ,(byte)0x00 ,(byte)0x00,
(byte)0xb0 ,(byte)0xaf ,(byte)0xba ,(byte)0xb1
};
</codetext>
</codeclip>
<codeclip>
<ID>_C38</ID>
<x0>166</x0>
<y0>101</y0>
<width>141</width>
<height>18</height>
<codetext>byte auth[] = {
(byte)0x41 ,(byte)0x55 ,(byte)0x54 ,(byte)0x48
,(byte)0x02 ,(byte)0x00 ,(byte)0x00 ,(byte)0x00
,(byte)0x00 ,(byte)0x00 ,(byte)0x00 ,(byte)0x00
,(byte)0x00 ,(byte)0x01 ,(byte)0x00 ,(byte)0x00
,(byte)0xa5 ,(byte)0x81 ,(byte)0x00 ,(byte)0x00
,(byte)0xbe ,(byte)0xaa ,(byte)0xab ,(byte)0xb7
};
</codetext>
</codeclip>
<codeclip>
<ID>_C37</ID>
<x0>166</x0>
<y0>80</y0>
<width>141</width>
<height>18</height>
<codetext>byte connect[] = {
(byte)0x43 ,(byte)0x4e ,(byte)0x58 ,(byte)0x4e
,(byte)0x01 ,(byte)0x00 ,(byte)0x00 ,(byte)0x01
,(byte)0x00 ,(byte)0x00 ,(byte)0x10 ,(byte)0x00
,(byte)0xc9 ,(byte)0x00 ,(byte)0x00 ,(byte)0x00
,(byte)0x24 ,(byte)0x4e ,(byte)0x00 ,(byte)0x00
,(byte)0xbc ,(byte)0xb1 ,(byte)0xa7 ,(byte)0xb1
,(byte)0x68 ,(byte)0x6f ,(byte)0x73 ,(byte)0x74
,(byte)0x3a ,(byte)0x3a ,(byte)0x66 ,(byte)0x65
,(byte)0x61 ,(byte)0x74 ,(byte)0x75 ,(byte)0x72
,(byte)0x65 ,(byte)0x73 ,(byte)0x3d ,(byte)0x73
,(byte)0x68 ,(byte)0x65 ,(byte)0x6c ,(byte)0x6c
,(byte)0x5f ,(byte)0x76 ,(byte)0x32 ,(byte)0x2c
,(byte)0x63 ,(byte)0x6d ,(byte)0x64 ,(byte)0x2c
,(byte)0x73 ,(byte)0x74 ,(byte)0x61 ,(byte)0x74
,(byte)0x5f ,(byte)0x76 ,(byte)0x32 ,(byte)0x2c
,(byte)0x6c ,(byte)0x73 ,(byte)0x5f ,(byte)0x76
,(byte)0x32 ,(byte)0x2c ,(byte)0x66 ,(byte)0x69
,(byte)0x78 ,(byte)0x65 ,(byte)0x64 ,(byte)0x5f
,(byte)0x70 ,(byte)0x75 ,(byte)0x73 ,(byte)0x68
,(byte)0x5f ,(byte)0x6d ,(byte)0x6b ,(byte)0x64
,(byte)0x69 ,(byte)0x72 ,(byte)0x2c ,(byte)0x61
,(byte)0x70 ,(byte)0x65 ,(byte)0x78 ,(byte)0x2c
,(byte)0x61 ,(byte)0x62 ,(byte)0x62 ,(byte)0x2c
,(byte)0x66 ,(byte)0x69 ,(byte)0x78 ,(byte)0x65
,(byte)0x64 ,(byte)0x5f ,(byte)0x70 ,(byte)0x75
,(byte)0x73 ,(byte)0x68 ,(byte)0x5f ,(byte)0x73
,(byte)0x79 ,(byte)0x6d ,(byte)0x6c ,(byte)0x69
,(byte)0x6e ,(byte)0x6b ,(byte)0x5f ,(byte)0x74
,(byte)0x69 ,(byte)0x6d ,(byte)0x65 ,(byte)0x73
,(byte)0x74 ,(byte)0x61 ,(byte)0x6d ,(byte)0x70
,(byte)0x2c ,(byte)0x61 ,(byte)0x62 ,(byte)0x62
,(byte)0x5f ,(byte)0x65 ,(byte)0x78 ,(byte)0x65
,(byte)0x63 ,(byte)0x2c ,(byte)0x72 ,(byte)0x65
,(byte)0x6d ,(byte)0x6f ,(byte)0x75 ,(byte)0x6e
,(byte)0x74 ,(byte)0x5f ,(byte)0x73 ,(byte)0x68
,(byte)0x65 ,(byte)0x6c ,(byte)0x6c ,(byte)0x2c
,(byte)0x74 ,(byte)0x72 ,(byte)0x61 ,(byte)0x63
,(byte)0x6b ,(byte)0x5f ,(byte)0x61 ,(byte)0x70
,(byte)0x70 ,(byte)0x2c ,(byte)0x73 ,(byte)0x65
,(byte)0x6e ,(byte)0x64 ,(byte)0x72 ,(byte)0x65
,(byte)0x63 ,(byte)0x76 ,(byte)0x5f ,(byte)0x76
,(byte)0x32 ,(byte)0x2c ,(byte)0x73 ,(byte)0x65
,(byte)0x6e ,(byte)0x64 ,(byte)0x72 ,(byte)0x65
,(byte)0x63 ,(byte)0x76 ,(byte)0x5f ,(byte)0x76
,(byte)0x32 ,(byte)0x5f ,(byte)0x62 ,(byte)0x72
,(byte)0x6f ,(byte)0x74 ,(byte)0x6c ,(byte)0x69
,(byte)0x2c ,(byte)0x73 ,(byte)0x65 ,(byte)0x6e
,(byte)0x64 ,(byte)0x72 ,(byte)0x65 ,(byte)0x63
,(byte)0x76 ,(byte)0x5f ,(byte)0x76 ,(byte)0x32
,(byte)0x5f ,(byte)0x6c ,(byte)0x7a ,(byte)0x34
,(byte)0x2c ,(byte)0x73 ,(byte)0x65 ,(byte)0x6e
,(byte)0x64 ,(byte)0x72 ,(byte)0x65 ,(byte)0x63
,(byte)0x76 ,(byte)0x5f ,(byte)0x76 ,(byte)0x32
,(byte)0x5f ,(byte)0x64 ,(byte)0x72 ,(byte)0x79
,(byte)0x5f ,(byte)0x72 ,(byte)0x75 ,(byte)0x6e
,(byte)0x5f ,(byte)0x73 ,(byte)0x65 ,(byte)0x6e
,(byte)0x64

};
</codetext>
</codeclip>
<codeclip>
<ID>_C36</ID>
<x0>167</x0>
<y0>170</y0>
<width>189</width>
<height>35</height>
<codetext>// DigestInfoデータ
byte digestInfo[] = {

(byte)0x30,(byte)0x21,(byte)0x30,(byte)0x09,
(byte)0x06,(byte)0x05,(byte)0x2b,(byte)0x0e,
(byte)0x03,(byte)0x02,(byte)0x1a,(byte)0x05,
(byte)0x00,(byte)0x04,(byte)0x14
};
</codetext>
</codeclip>
<operation>
<ID>_O35</ID>
<state1>_SINIT</state1>
<state2>_SINIT</state2>
<x0>164</x0>
<y0>286</y0>
<width>197</width>
<height>49</height>
<inconnectx0>0</inconnectx0>
<inconnecty0>40</inconnecty0>
<outconnectx0>0</outconnectx0>
<outconnecty0>40</outconnecty0>
<inpintext>in(int key)</inpintext>
<inpinx0>0</inpinx0>
<inpiny0>28</inpiny0>
<inpinwidth>97</inpinwidth>
<inpinheight>21</inpinheight>
<outpintext>out()</outpintext>
<outpinx0>90</outpinx0>
<outpiny0>40</outpiny0>
<outpinwidth>40</outpinwidth>
<outpinheight>20</outpinheight>
<inpinlinkcount>1</inpinlinkcount>
<description></description>
<codetext> // キー入力コマンドを実行



Log.d(&quot;vkeyboard&quot;,&quot;recognise out key=&quot;+key);
   String cmd = &quot;input keyevent &quot;+key;
   try {
      int n,s;
      
      // ポートを開く
Log.d(&quot;vkeyboard&quot;,&quot;open localhost port 5555&quot;);
      Socket socket = new Socket(&quot;127.0.0.1&quot;, 5555);
      InputStream in  = socket.getInputStream();
      OutputStream out = socket.getOutputStream();
      socket.setTcpNoDelay(true); // 小さなパケットなのですぐ応答するようにしておく

      // ADB接続要求を送信
Log.d(&quot;vkeyboard&quot;,&quot;cnxn&quot;);
      out.write(connect);
      out.flush();

      // トークンを受信
Log.d(&quot;vkeyboard&quot;,&quot;recv token&quot;);
      in.read( recv, 0,  24);
      n = ((int)recv[12]&amp;0xff)+((int)recv[13]&amp;0xff)*0x100;
Log.d(&quot;vkeyboard&quot;,&quot;size=&quot;+n);
      byte[] token = new byte[n];
      in.read( token );

      // トークンから署名を生成
Log.d(&quot;vkeyboard&quot;,&quot;create private key&quot;);
      encipher.init(Cipher.ENCRYPT_MODE, privkey);
      encipher.update(digestInfo);
      byte[] enc = encipher.doFinal(token);
      n = enc.length;
      s = check_sum(enc);

       // 署名を送信
Log.d(&quot;vkeyboard&quot;,&quot;send auth&quot;);
      auth[12]= (byte)(n &amp; 0xff);
      auth[13]= (byte)((n&gt;&gt;8) &amp; 0xff);
      auth[14]= (byte)((n&gt;&gt;16) &amp; 0xff);
      auth[15]= (byte)((n&gt;&gt;24) &amp; 0xff);
      auth[16]= (byte)(s &amp; 0xff);
      auth[17]= (byte)((s&gt;&gt;8) &amp; 0xff);
      auth[18]= (byte)((s&gt;&gt;16) &amp; 0xff);
      auth[19]= (byte)((s&gt;&gt;24) &amp; 0xff);
      out.write(auth);
      out.write(enc);
      out.flush();
  
      // バナーを読み込む
Log.d(&quot;vkeyboard&quot;,&quot;read banner&quot;);
      in.read( recv, 0, 24 );
      n = ((int)recv[12]&amp;0xff)+((int)recv[13]&amp;0xff)*0x100;
      in.read( recv, 24, n );

      // キー入力コマンドを作成
Log.d(&quot;vkeyboard&quot;,&quot;create keycommand&quot;);
      String cm = &quot;shell:&quot;+cmd;
      n = cm.length();
      byte[] command = new byte[n+1];
      for(int i = 0; i &lt; n; i++) { command[i] = (byte)cm.charAt(i); }
      command[n] = (byte)&apos;\0&apos;;
      n = command.length;
      s = check_sum(command);
      open[12]= (byte)(n &amp; 0xff);
      open[13]= (byte)((n&gt;&gt;8) &amp; 0xff);
      open[14]= (byte)((n&gt;&gt;16) &amp; 0xff);
      open[15]= (byte)((n&gt;&gt;24) &amp; 0xff);
      open[16]= (byte)(s &amp; 0xff);
      open[17]= (byte)((s&gt;&gt;8) &amp; 0xff);
      open[18]= (byte)((s&gt;&gt;16) &amp; 0xff);
      open[19]= (byte)((s&gt;&gt;24) &amp; 0xff);
      
      // キー入力コマンドを送信
Log.d(&quot;vkeyboard&quot;,&quot;send keycommand&quot;);
      out.write(open);
      out.write(command);
      out.flush();

      // クローズコマンドを送信
Log.d(&quot;vkeyboard&quot;,&quot;read close command&quot;);
      in.read( recv, 0, 24 );
Log.d(&quot;vkeyboard&quot;,&quot;send close command&quot;);
      in.read( recv, 24, 24 );
      close[4]  = recv[8];
      close[5]  = recv[9];
      close[6]  = recv[10];
      close[7]  = recv[11];
      close[8]  = recv[4];
      close[9]  = recv[5];
      close[10] = recv[6];
      close[11] = recv[7];
      out.write(close);
      out.flush();

      // ポートを閉じる
Log.d(&quot;vkeyboard&quot;,&quot;close port&quot;);
      socket.close();
    } catch(Exception e){
      is_running = false;
      e.printStackTrace();
    }
</codetext>
</operation>
<ID_maker>52</ID_maker>
<pin>
<ID>_P43</ID>
<x0>4</x0>
<y0>298</y0>
<width>120</width>
<height>25</height>
<text>type(int key)</text>
<px>0</px>
<py>59</py>
</pin>
<relation>
<ID>_R44</ID>
<pin1name>_P43</pin1name>
<pin2name>_O35</pin2name>
</relation>
<operation>
<ID>_O45</ID>
<state1>_SINIT</state1>
<state2>_SINIT</state2>
<x0>169</x0>
<y0>360</y0>
<width>116</width>
<height>50</height>
<inconnectx0>0</inconnectx0>
<inconnecty0>40</inconnecty0>
<outconnectx0>0</outconnectx0>
<outconnecty0>40</outconnecty0>
<inpintext>in()</inpintext>
<inpinx0>1</inpinx0>
<inpiny0>31</inpiny0>
<inpinwidth>40</inpinwidth>
<inpinheight>20</inpinheight>
<outpintext>out()</outpintext>
<outpinx0>90</outpinx0>
<outpiny0>40</outpiny0>
<outpinwidth>40</outpinwidth>
<outpinheight>20</outpinheight>
<inpinlinkcount>1</inpinlinkcount>
<description></description>
<codetext>// 初期化 


      // 秘密鍵の生成
      byte[] privateKeyAsByteArray = null;
      try {
        int i = 0, cnt = 0;
		android.content.res.Resources resource = SERVICE.getResources();
        java.io.InputStream is = resource.openRawResource(R.raw.adbkey);
        while (is.read()!=-1) cnt++;
        privateKeyAsByteArray = new byte[cnt];
        is.reset();
        is.read(privateKeyAsByteArray);
        is.close();
        encipher = Cipher.getInstance(&quot;RSA/ECB/PKCS1Padding&quot;);
        PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(privateKeyAsByteArray);
        KeyFactory kf = KeyFactory.getInstance(&quot;RSA&quot;);
        privkey = (RSAPrivateKey) kf.generatePrivate(keySpec);
      }catch(Exception e){}

</codetext>
</operation>
<codeclip>
<ID>_C46</ID>
<x0>167</x0>
<y0>34</y0>
<width>214</width>
<height>20</height>
<codetext>RSAPrivateKey privkey = null ;</codetext>
</codeclip>
<pin>
<ID>_P47</ID>
<x0>21</x0>
<y0>385</y0>
<width>60</width>
<height>30</height>
<text>init()</text>
<px>5</px>
<py>31</py>
</pin>
<relation>
<ID>_R48</ID>
<pin1name>_P47</pin1name>
<pin2name>_O45</pin2name>
</relation>
<codeclip>
<ID>_C50</ID>
<x0>165</x0>
<y0>215</y0>
<width>267</width>
<height>33</height>
<codetext>// チェックサムを計算する
public int check_sum(byte[] payload) {

  int checksum = 0;
  for(byte b : payload) {
    checksum += (int)b &amp; 0xff;
  }
  return checksum;
}
</codetext>
</codeclip>
<codeclip>
<ID>_C51</ID>
<x0>166</x0>
<y0>8</y0>
<width>168</width>
<height>21</height>
<codetext>Cipher encipher = null;
</codetext>
</codeclip>
</xobject>
<relation>
<ID>_R44</ID>
<pin1name>_X34(_P88)</pin1name>
<pin2name>_X42(_P47)</pin2name>
</relation>
<relation>
<ID>_R45</ID>
<pin1name>_X34(_P114)</pin1name>
<pin2name>_X42(_P43)</pin2name>
</relation>
<xobject>
<ID>_X46</ID>
<x0>181</x0>
<y0>448</y0>
<width>173</width>
<height>58</height>
<ID_maker>17</ID_maker>
<objectname>File_IO</objectname>
<description></description>
<pin>
<ID>_P1</ID>
<x0>23</x0>
<y0>70</y0>
<width>65</width>
<height>29</height>
<text>save()</text>
<px>0</px>
<py>42</py>
</pin>
<pin>
<ID>_P12</ID>
<x0>26</x0>
<y0>12</y0>
<width>60</width>
<height>30</height>
<text>load()</text>
<px>0</px>
<py>28</py>
</pin>
<operation>
<ID>_O13</ID>
<state1>_SINIT</state1>
<state2>_SINIT</state2>
<x0>115</x0>
<y0>6</y0>
<width>312</width>
<height>50</height>
<inconnectx0>0</inconnectx0>
<inconnecty0>40</inconnecty0>
<outconnectx0>0</outconnectx0>
<outconnecty0>40</outconnecty0>
<inpintext>in()</inpintext>
<inpinx0>0</inpinx0>
<inpiny0>29</inpiny0>
<inpinwidth>40</inpinwidth>
<inpinheight>20</inpinheight>
<outpintext>out()</outpintext>
<outpinx0>90</outpinx0>
<outpiny0>40</outpiny0>
<outpinwidth>40</outpinwidth>
<outpinheight>20</outpinheight>
<inpinlinkcount>1</inpinlinkcount>
<description></description>
<codetext>//音声テンプレートを読み込む(無い場合は作成する)


try{
  dbg = new FileWriter(new File(Environment.getExternalStorageDirectory(), DEBUG_FILE));
} catch(Exception e){}


try{

if(!voice_data_file.exists()){
  int cnt = 0;
  InputStream is = SERVICE.getResources().openRawResource(R.raw.voicedata);
  while (is.read()!=-1) cnt++;
  byte[] b = new byte[cnt];
  is.reset();
  is.read(b);
  is.close();
  FileOutputStream os = new FileOutputStream(voice_data_file);
  os.write(b);
  os.close();
}

String line = null;
BufferedReader din = new BufferedReader( new FileReader(voice_data_file));

// 変数を読み込む
while(true){
  if( ( line=din.readLine() ) == null ) return;
  if( line.equals( &quot;&quot; ) ) break;
  if( line.equals(&quot;debug_mode=true&quot;))         debug_mode=true;
  if( line.equals(&quot;debug_mode=false&quot;))        debug_mode=false;
  if( line.equals(&quot;flog_scale=true&quot;))         flog_scale=true;
  if( line.equals(&quot;flog_scale=false&quot;))        flog_scale=false;
  if( line.equals(&quot;alog_scale=true&quot;))         alog_scale=true;
  if( line.equals(&quot;alog_scale=false&quot;))        alog_scale=false;
  if( line.equals(&quot;auto_learn=true&quot;))         auto_learn=true;
  if( line.equals(&quot;auto_learn=false&quot;))        auto_learn=false;
  if( line.startsWith(&quot;startup_time=&quot;))       startup_time=Integer.parseInt(line.substring(13));
  if( line.startsWith(&quot;sound_filter=&quot;))       sound_filter=Double.parseDouble(line.substring(13));
  if( line.startsWith(&quot;thresh_trigger_on=&quot;))  thresh_trigger_on=Double.parseDouble(line.substring(18));
  if( line.startsWith(&quot;thresh_trigger_off=&quot;)) thresh_trigger_off=Double.parseDouble(line.substring(19));
  if( line.startsWith(&quot;thresh_count_on=&quot;))    thresh_count_on=Integer.parseInt(line.substring(16));
  if( line.startsWith(&quot;thresh_count_off=&quot;))   thresh_count_off=Integer.parseInt(line.substring(17));
  if( line.startsWith(&quot;thresh_recognize=&quot;))   thresh_recognize=Double.parseDouble(line.substring(17));
  if( line.startsWith(&quot;bias=&quot;))               bias=Double.parseDouble(line.substring(5));
  if( line.startsWith(&quot;acompress=&quot;))          acompress=Double.parseDouble(line.substring(10));
  if( line.startsWith(&quot;learn_param_o=&quot;))      learn_param_o=Double.parseDouble(line.substring(14));
  if( line.startsWith(&quot;learn_param_x=&quot;))      learn_param_x=Double.parseDouble(line.substring(14));
  if( line.startsWith(&quot;limit_length=&quot;))       limit_length=Double.parseDouble(line.substring(13));
}

hosei = new double[HEARING_HEIGHT];
for(int i = 0; true; i++){
  if((line=din.readLine()) == null){din.close(); return;}
  if( line.equals( &quot;&quot; ) ) break;
  hosei[i%HEARING_HEIGHT] = Double.parseDouble(line);
}

// 音声データを読み込む
voice_template = new Vector();
while(true){
  if((line=din.readLine()) == null){din.close(); return;}
  if(line.equals(&quot;END&quot;)) break;
  String t = line;
  if( ( line=din.readLine() ) == null ){din.close(); return;}
  double w = Double.parseDouble(line);
  if( ( line=din.readLine() ) == null ){din.close(); return;}
  int c = Integer.parseInt(line);
  if( ( line=din.readLine() ) == null ){din.close(); return;}
  int s = Integer.parseInt(line);
  double[] v = new double[s];
  for(int i = 0; i &lt; s; i++){
    if((line=din.readLine()) == null){din.close(); return;}
    v[i] = Double.parseDouble(line);
  }
  voice_template.add(new VoiceTemplate(t, w, c, v));
}

din.close();
} catch( Exception e ){ dprint(e+&quot;\n&quot;); }

voice_no = 0;
</codetext>
</operation>
<operation>
<ID>_O14</ID>
<state1>_SINIT</state1>
<state2>_SINIT</state2>
<x0>113</x0>
<y0>64</y0>
<width>194</width>
<height>50</height>
<inconnectx0>0</inconnectx0>
<inconnecty0>40</inconnecty0>
<outconnectx0>0</outconnectx0>
<outconnecty0>40</outconnecty0>
<inpintext>in()</inpintext>
<inpinx0>0</inpinx0>
<inpiny0>29</inpiny0>
<inpinwidth>40</inpinwidth>
<inpinheight>20</inpinheight>
<outpintext>out()</outpintext>
<outpinx0>90</outpinx0>
<outpiny0>40</outpiny0>
<outpinwidth>40</outpinwidth>
<outpinheight>20</outpinheight>
<inpinlinkcount>1</inpinlinkcount>
<description></description>
<codetext>//音声テンプレートを保存する

try{
  BufferedWriter dout = new BufferedWriter( new FileWriter(voice_data_file) );
  
  // 変数を保存する
  dout.write(&quot;flog_scale=&quot; + flog_scale + &quot;\n&quot;);
  dout.write(&quot;alog_scale=&quot; + alog_scale + &quot;\n&quot;);
  dout.write(&quot;auto_learn=&quot; + auto_learn + &quot;\n&quot;);
  dout.write(&quot;startup_time=&quot; + startup_time + &quot;\n&quot;);
  dout.write(&quot;sound_filter=&quot; + sound_filter + &quot;\n&quot;);
  dout.write(&quot;thresh_trigger_on=&quot; + thresh_trigger_on + &quot;\n&quot;);
  dout.write(&quot;thresh_trigger_off=&quot; + thresh_trigger_off + &quot;\n&quot;);
  dout.write(&quot;thresh_count_on=&quot; + thresh_count_on + &quot;\n&quot;);
  dout.write(&quot;thresh_count_off=&quot; + thresh_count_off + &quot;\n&quot;);
  dout.write(&quot;thresh_recognize=&quot; + thresh_recognize + &quot;\n&quot;);
  dout.write(&quot;bias=&quot; + bias + &quot;\n&quot;);
  dout.write(&quot;acompress=&quot; + acompress + &quot;\n&quot;);
  dout.write(&quot;learn_param_o=&quot; + learn_param_o + &quot;\n&quot;);
  dout.write(&quot;learn_param_x=&quot; + learn_param_x + &quot;\n&quot;);
  dout.write(&quot;limit_length=&quot; + limit_length + &quot;\n&quot;);
  dout.write(&quot;\n&quot;);

  for(int i = 0; i &lt; HEARING_HEIGHT; i++){
    dout.write(hosei[i] + &quot;\n&quot;);
  }
  dout.write(&quot;\n&quot;);
  
  // 音声データを保存する
  for( int i = 0; i &lt; voice_template.size(); i++ ){
    dout.write(((VoiceTemplate)voice_template.get(i)).text + &quot;\n&quot; );
    dout.write(((VoiceTemplate)voice_template.get(i)).weight + &quot;\n&quot; );
    dout.write(((VoiceTemplate)voice_template.get(i)).code + &quot;\n&quot; );
    double[] v = ((VoiceTemplate)(voice_template.get(i))).voice;
    dout.write(v.length + &quot;\n&quot;);
    for (int j = 0; j &lt;  v.length; j++){
      dout.write(v[j] + &quot;\n&quot;);
    }
  }
  dout.write(&quot;END\n&quot;);
  dout.close();
} catch( Exception e ){dprint(e+&quot;\n&quot;);}
</codetext>
</operation>
<relation>
<ID>_R15</ID>
<pin1name>_P12</pin1name>
<pin2name>_O13</pin2name>
</relation>
<relation>
<ID>_R16</ID>
<pin1name>_P1</pin1name>
<pin2name>_O14</pin2name>
</relation>
</xobject>
<relation>
<ID>_R48</ID>
<pin1name>_PSTART</pin1name>
<pin2name>_X46(_P12)</pin2name>
</relation>
<relation>
<ID>_R49</ID>
<pin1name>_X46(_P12)</pin1name>
<pin2name>_X34(_P88)</pin2name>
</relation>
<ImgIcon>
<ID>_I50</ID>
<x0>670</x0>
<y0>4</y0>
<width>122</width>
<height>113</height>
<image>ppinppaoaaabkegejegeaabacaaaaabaaabaaaaapplnaadeaaiagagahagafaia
hahahajajaiakamaebnamalalamajbcbdbpaebnbkbpbobnbkbmbmbacecochcac
ccmcdcmbmbichdjcmcadbdedededpbhcjdndidcdmdocddedcdpplnaadebajaja
jamalamaibnanaibcdbcmbbccdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd
cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdppam
aabbiaaacjaaejdabaccaacabbbadabbbappemaapbaaaabafababababababaaa
aaaaaaaaaaaaaabacadaeafagahaiajakalappemaaflabaacabadadacaeadafa
faeaeaaaaabanhbacadaaaeabbfacbbcbdbegadbbfbghaccbhebcdbibjbkiadc
ceblbmfbcfbnapecddcgchcijakagbhbibjbkbfcgchcicjckcedfdgdhdidjdkd
deeefegeheiejekedfefffgfhfifjfkfdgegfggghgigjgkgdhehfhghhhihjhkh
dieifigihiiijikicjdjejfjgjhjijjjkjckdkekfkgkhkikjkkkcldlelflglhl
iljlklcmdmemfmgmhmimjmkmcndnenfngnhninjnknbocodoeofogohoiojokobp
cpdpepfpgphpipjpkpppemaapbbaaadabababababababababaaaaaaaaaaaaaba
cadaeafagahaiajakalappemaaflbbaacabacaeaeadaeahafaeaeaaabacahhaa
bacadabbeafabcbdgacbbebfhabgbhdbcccdbiiaebcebjbkblbmjadcddcfapfb
cgchbnkagbecedbofcbphbibjbkbgchcicjckcfdgdhdidjdkddeeefegeheieje
kedfefffgfhfifjfkfdgegfggghgigjgkgdhehfhghhhihjhkhcidieifigihiii
jikicjdjejfjgjhjijjjkjckdkekfkgkhkikjkkkcldlelflglhliljlklcmdmem
fmgmhmimjmkmcndnenfngnhninjnkncodoeofogohoiojokocpdpepfpgphpipjp
kpppknaamadabaaacabbdabbaapdaahpmocncncggjaikaicckaikaicekgcaima
mjdfdenhphmchfnccopfibkfioldnccgminnkodlcabgclgedmabialmbdbminak
mbeooikhaajefmdebopdeblmcogapldlolgiicfhlbgcdeccaefodoihnnchokek
miaoaociiaimackiaamoikgkgjamnojpenlfgmheofkhbhopphkchfaepefeadgd
lhohheedemjjecbabjfjbiiobeomohejamkjkiicakcakiicakcakiicakcakiic
akcakiicakcakiicakeamknilghfhlbnedllnicehonpmfdcoodilmblidffdajl
cgaeobgofljeampkedipdigpnilgemkbhbficonjbogighcjcpnodnjdbbgmaaaf
idkojepgbkaalpgfffkckcbhchlhbcfkhhdgdbcelenicfhobflllfieokfplbjk
helnpcnjkmdmlafiacccfijpekiaadakmabaciifciienkllpbiahefaemhjhfkf
fkmphpchaknionjbneklfjeaajhagjdeagcbpemcoejehokjkncicnlalcienkng
cgieagjicehmkbmakcbaanaakddhpnpkhcmjmjenmobmabdlidffhacjiepboipe
fbcpihmnknnlkgoiednbbjlnkbbdkimlmipgipeeehdehcijnghgdppdolpgokhd
phpnofggphkfclkleegnlkppaacbnnlgefelbhanedgobopeblcboopmgopanldd
fehnnofdlmjhegaieibdkmbnebgglboioaddmihopbhofdkkjehccjfejhdjmmbl
ijjhcpommeilcmmjfncobhkheokdfmfmbopgcbpnjedhckhbaaljadbnbeiambgb
kjfdfcindbhmonkchaecbanmogipcbiaelnnpfemknndjlhlgbahmfbemdbbcmil
fejfcgeanojbdceajkhmdokflljdaoajbhmiaocbhadopoomkhhonlagihdgnehi
dmonjdennkdcggabkgglbjnmkgekmjgebgcgobfdomihobigacghmboajjpkdkkm
dhhglinpmnopecdhffdkjmkkndmcmbkikfbecngjoleihokaicckaikaicckaika
icckaikagomddecolcnpgbigccelapfpopikeceadllncdicoeaeaaoodcechofl
ehfphoolndapnlhniiogmoonnbdajeencjibinpgolklcjdcjbeccbaabeimidho
pdfkaaigihpggmdmlffnpoehlknjobdplelldljifcbjocjjkhbdacdgeakpohak
hfiffcgfmbabbeepjdpokibpffapmfolmbbnfhlonpkehndmknngfjcokfemglom
fgojnncekmoahodcnajmgmaakoinecaibdcfjoobecgjbhbopnjaihcehppedpml
gopjafpjoejimliiacgfecaiclegfodldijmhohkkfaafpdgjklfljliiibkbjhc
kjmndamcbdadhgcfbeacbbojjaaadohngamlfmmdfflgdhdolbnmleefdlolclkl
glbimggnimkfjmdcemfkligiajikacddmaabgaihdahcojhdedldlinegbpmgmof
kcpnmackcogpjedaembmlimckebbafbjpjconabimimpnnlomjdnaokjlafehdpe
olcpghjgoomfajlakeeogjacobkibaamnbaicaalpkcefdakboncjjbfhjlcjlil
onjdapmoecjphncpambajbdpmkhopijbgmkdakeohohkdngncjdofmojcbenngfk
gljlgnmgofonbegleebjkmcaddbimjaooihibjjomfhjjikalkifjmchokedipem
cliefflajcajgeeebcglciahmfdokogabhgnikihpcleefanmdldfhcgbpmnmfke
hlleehgjoolakcgjmmfgameonhmnchpdiihndjnpnihieijlckknblllnkgcmkom
hkcmkhphgiedfccdhenkjghnhdcjgbobchomdkkapenngmiedconklepplclghcm
onlfbddcdcmgakhomihociihfmkfnghbkejldngepjncnkdkoeacjbpakbhjofbd
ilciddmidiknmlpdemknfamlhjkbnlelgjbnnaagkogfglallnokdaiikecijfhe
ahmmieimjodikjhoemegbhpkodkhdjegdnnkmodoigdkkngngohabccfigjnoiae
babijmobijfddjjkdjpblimphcbcnehknohhbbgjmdoangpnfopdcfebpicfhake
fofhpoiaiogfohecmjgcjjpgnbhkjndkbaiekackaeifegagciidbmjdfpkkncfg
bolhhlgbkongefgjfaeahbbamfbbmjfbkcihdchcgaglamfgabdmgfffbclcmpli
njhgicknhmllhijmmbfpppaapdeneffleoklpbemlondpdfelpgblkfhncgphlfa
mmglcmlbiglmneahkkpndcbjammfjkaagjdcbkndlkffoddckobakflhpkgalgbd
jfoimebneddhadobfkebcjodmjhnolchojlifeagioohbccnmhheegogelllinok
cghalgmoimegndadkmaefgodaiailghhpdkeaakficckaikaicckaikaogonbdoe
ckaijclmngmajmcliggnfendffamaccppadeoobagkhefgpgmaljbociiclngkbf
aaideppmhkfpikflngpgneanmoophnkkofbmhgpgajdammlpgenhodflmmplfmpl
fapoihnofpdgdhccfhoionknjfibnpadilpdnjaabebpbdnapkdignibdjbbpmnh
ngmbljefmajcjjjedombeoaibdanhofkbhhfkdfgnpepmmponkmflfemlflafbkk
kcaildfooijeodmpnhlcakbpphkielphabihkfkokmhaolglkjhfdfjgndfnejbl
hmgpiikmkljkggaamaajaajmdaeckpgfgejjikgkjkaghlccgcbijmjcmcncaidg
fhidfgdcoliampihfmaakbhffimlbehhahfeoimlfgffaaimpgnkfjgmadbebahj
lgmaaooigillponamflfdlmfjgcnfedgobjkcgikhclfeemgmgbgfjagmmdkacai
gechjheaobbefbfjbopknajgkjkkmfnmikjaokjiahmdjjgcpgiccahaobifbcpe
bckldilfkbhidimcooeoflojcmgonhgccpbnkbicocmccijkifineogkcnkafjim
mbabahgegejaecgkdjnbkmkdpjmiehnehdfmgpkjnfkncknnclmggjnoillfcgin
icminnhldgdchcdnidimdkhmbniolobojnhggnngfklgfhbcnaenbdlkjmbahcfo
acoboeiffiaombgbhaaaegoipceealoijnflpfoakobnnkfmmohbmcogkjbgdjeh
midhmbekojakokhahacibdgmgafdmhfbakjfofkohbdhlmncmokpghljehblinln
nmchcnceecffdmadeamjfjggacdamjbbhmoebckeoommgnehcjkicjhgbcjgngak
iflfamklejnkfdbmaepelnmiokdahhaaiecaapbdankaiomchcdnooailghcciae
himkagegpbbekieppefbemhkhejgbddpgekoefhoojoeiahodpokgajgcfiafcjj
infanijfijblimibeamjopdapjmefnekgjgmhcldaoloeelflflngpfedpoopghc
nagcjdkcokefmafpnbiadonbneehgpkloohidklggnlgjkkgalknomhmchgmffjj
glhoaallaaceciiedabhmbgppomfgjnjdhlhgkihkaonlhlejfhcplillmhmiajb
dmimeoeolpchoalgpliplghkiokhpiaibelphdkngknlockjhkknefddmldmbcdi
bpanghhmaefeadociplicmcnjmghonbcapdlfcojoldkfcgimdlkfmhmmnajoaek
oidefhmbdhnmldieippjdkonmfbmbgjkfefhekkocdbbjbcigpgbfecbhhbegcgd
djjodnedpngigoihmkfhnflcmmjhepnplcafcjomkmjfjhdhibbmkcoeoeceblam
odaikhhfjenkiggjofaccnooednncefbkjonehkcbenbddmnobemghdcbjaekbbm
cpinhmloopnhplkdcjilphgiknninnppaadibkoiopbfncfoejcnjnlmhcjhmame
efbdmpaappaakbooicaackkiicaackkiicdaiiipdibolapjgbjggpcgkmcoibpo
ehlpfjklbiocdbehcdadophbibmdpbhmjocfiplbmfklgneplkjifdlalalflcln
lhjkncfgielbacejaccbideacaiehmkflokmnpdhfpfmahkdgidjnkihpgemhlkh
hphinkfenpnjlplckgkbognpminfefbiecmeihjmibimhmidloaenbofjkfkkflg
kbnhfmfimojafdeljoblbnenadodipdcikmddiindpofdcdhbhchkjnbfmeofank
mlbffkkcoknkhkleobbnphcbnjlkadhalkfajbmcjlbmaaabahgknlkcpepbnflf
cglhpnialogjgnaacolfhjnipegjnhghjcmcheilfbdfifgnehngoglcnchelecj
kmjpenhlhjghekjbcceaabefoaiaimecabhecelhdpaeebmdnbcoljifflieepnn
aefkmjhnbnmcajdckeokclcijefamfmbgdbejdnbhebhofckifkbapiomhpcbkln
jignnbcdfadbajecaabbildaojjdamhobkibhmkglibfbpgdflboeioildpgfbpe
ccjllapgfgndclnfieemmjagbddmdgmncjicdadnmlfebolapcabmfbeghdpmfjf
pflnegbejhkgcejmibndhfajdedaiobegmoekdgnoihickknigkdnfolnjcgmkgl
apcabadggjcgjeecdjmncjjehcjlpkddnelghmchmgcdihkjgnfbfgeackjoikib
mbegoijejodfocdkdojilbmgohkchfpgbefkeepedpfkfgiloonolgnjhgmifhfb
ffkipmahfedammajblamdamipapkpdfkjhnfemcniholdfdgegkeigjkpielnnag
pielagcidcofhijgdcdjomdhanhfeeojjagnfhlndjgdflhhlhjkhafogjfgifbc
echgeakkaiibmaepacepnkngdeeeljeeifdgfhmiceefmkggbdcmbjinoaenemhg
kkeibekbokenbfaiakaphaakobijhmfopeapfapmgppeemnbhfiemcfeoljkoghl
alokihjfdfkcipobaociohcidjmdgoikeegopncoheeiogdjnidnmflfblnbdmee
ihmpiapmboaelbknmiodgcapogpklkmfiplhiekdnlgjlkbcilifejaingokahfb
jieamilkfhdoibhplkdbihppaajfenngohdmckiplfcfoplnacecjihhpbhjfadl
ojfkmjapamlhhfbkjhmhhodcidgmphpdbpfkbddimjepndbegoaiadmdfcakpcgi
edlanflcnmjgfomiddlmddmajbecggmcmmjhidjmecdogcklkdogpndmjooeakca
kiicakcakiicakcackkaaadadninfhfpjkigakiagpmaagehjoipkhhfbdokmhod
apgmplbcojpoleoildmlmbmflndjmaakojlphjjbpdmfhnffkigomllecoikehba
lgeagfdjpfkohjmmcfomcmmnaicpfjjbcgjeboffheecojejbajmpbfikbcjbloi
pclbkglclgmiianmelfgbpjollpipmfbpegmphpaelndpaboonnkjhngdalmkkde
kbpmnpbkdhbccjcgiokmgelaahgabaibaapakgnjmplhdodidcfaanehihkebpcl
legncgpaenocnaegihdiofbppekiepdhakofioglglgfhlocckgooolankaogeib
bdbaieeahgaahgmdmafpaknanhkcgcfngcelnichnagmjadaalkophkeeplolflb
lhiceigfbpmckgndaagoilphjagmlknkakafaaoigckandadbdmplkanigballih
hopknkbgipclfbnhkaheidgchdcfpdcbbaopfhnlifonkcacihkhhokopjkpabak
paldkkmadhdopiiagcoddgikddpicmhchcjpkiplefmocchdphebmpnciaacfkkl
nfnfpdohghfapboeneaalhffebcfggaigbdjedelijakfackkiicaackkiicaack
kiicaapkddbplhfdhiemnacafpjmjafhbghhegmigecejmcpalpbcfbadaoibhof
jjmfhmmimlndhciiephchlglhjimplfignlhjdbpdjmbikchhkiojhhaloaembae
dcfikolhpadfmnaobhbiaeaaaiaepmidomgaiempjdmdefkndfpbcbkfpefcelpd
hgfnnkmnhmphfkimceflmlaicpbeidfaiebmeaahbeloojlchcgmohmbcldnflng
gblppflgelbnmmcfbedhdhnglcdalgldabdgcgefdboibddnmihoknaikdpimaom
glkneoohbgcoffkcoapaeaepnoofjiojjaepfppkjbdlapgkjkhhigpgmdfcdolb
ncogfnlfeokibpbakcgeahmaliojihoofaehgloledbpgehjcapkiimdhbmhcemi
lbnkgdefjlgeobllbeeaafhabkehfbpmipglfhnefbckpdkhhfffafpabkeapjdm
fbhipcfmppaaiakfikhbhnhhgjcdobbjnfifmemiphfdhmloifhnofjcelbplfnh
gkgmcojdnkcgfcaaniclefajoapejbhahacnailclpehndkopahapnjnpcfmlgip
ooggjadhfbejgfgniompgaghmmoiakepnamibhenaogpjblkajemobcemfbiebbg
ekejdjaifbbeecholngajlpdpakfdenkighlhdhpkgmbkohjcfnfnbmkhhicmagh
bgbiimfglabjoigeoejhgoaiodbihfnajoepimedmphfljihlhfmclifnmgbbjco
jdhiijmocbdncfahfbhgecahclagbgpfibaaojibepjdconlmbjdpdcmbehpakha
bnfeebaabffeebaabffeebaabffeebaadfkamieppbiihkcnafhagjiplmoelpph
miellhnhablbpgbbilcdjejkcebhgplhffacblbjpecbcaiekaibobbejdnoofbj
ecicbpibfoffajbbgimaakdiipobkddpmfgbdllhpceimpjhpciipcmgochgcnpk
mkcjjnhohliiimgnpklbbllbejdhelgiomaeidhmkhgjphpbonlgbdljphiaighh
hlhnmaadogogcogdgpaplpcjaodbepcaaijbngjgpgjgbpkhbefkcebjmckjjfnh
ieeegagncgdokmecbabmampgmekiepndplojbdojipokhfcmodgbpfpalfmnjebh
ghhnklflmoojngfplomajblfajaaaaapakahhakglobdaefbeooijchfmgbjdkpa
ceakpienhfljiokjeckfhkiimdpfeoclembpkokiiknnhfobkecbilnooidhponf
hkkifljgedpcmakgklekkeoblflejffcfendinjcdcapcoikihlbaepiceapmnac
kmdnononcooocpboomkfjgmfcammnhllafhabdconjldmoknnfpkfinogkpcjkih
ciaolfdlbicialjcnabddamjaajljbpmecfnnndhamgginppaaigipcgedgiboeb
mcglfcgldmghebbgphmnbhkogapaahjgmgmankbpdjdfkballncdinakcnhaapij
dhjjiepdonnnhldcdnnlkhiaoeoajhnopmmdafhanicdlfpnlnmndeedhaeodgnb
fnmkjpnalaobkailodnlbaeacijdhambgnoodikkkoobkbalhfenfclhpjpahaic
ocnfdlfciiaonahonjbncibhmjcjmldbbjcjkdnbdhdmlkjkpmnbnomicolmffii
bbnaanneamoiiokoihfhndbmbmhaajbegkioknconnkmehnkcfenjgkpemiemegj
oghhmkiibabacoagaafhdcdnbjcjiagaaikdiemniebiengicfbacfekabhecgna
jfokpddmabphegpnkokfebeeljlcgdjenggamoijdodjechmmjcjaeaginpmbebi
lnfdhngoaimabnfeebaaelbffeaaebbffeaaebijfkckaiibafobldcfmodoaaao
dgebkoicbabdojelelbfaeebfdnggdnblfiemldnhkppaadffhlacmmpghaghefp
okheamkdelcjjghabeenpafjnkigamlfnngehmgjafohhfhaklclaidhlnhkmghn
ihgelgfjbphbdimcfhllikfhfailildnfpiebaifpgmopnegkioaodcfkdadaoah
begpfmaadgipmmmcodocapfgeolgopgjkldjamaimbohkoieoimpdihnoodimohe
nlkhabeohfhbckipgclgnfcgnbhgmfgnoofhnlgejnkbldjgfcjicgleahmnbdff
pfcodccidhlonfakibebaaailhgnobnkbolpnckgiccgplhehhfihlfeedmgdgcj
ddanfjfgacmioiiambobdombgffpebbadidkiogbklhcknmapabhmchjoakbjfok
gcjgnbimibjbmcpeaahgdpnkmnafbefpfmncaagcicfkckaikaicckaikaicckai
kaicckaikaicckaikaicckaikakeicakfackkiicaackkiicaackkiicaackkiic
dappjn</image>
</ImgIcon>
<pin>
<ID>_P51</ID>
<x0>88</x0>
<y0>512</y0>
<width>60</width>
<height>30</height>
<text>save()</text>
<px>10</px>
<py>40</py>
</pin>
<relation>
<ID>_R52</ID>
<pin1name>_P51</pin1name>
<pin2name>_X46(_P1)</pin2name>
</relation>
</xobject>
